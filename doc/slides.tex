\documentclass{beamer}

\usepackage{minted}
\usemintedstyle{eclipse}

\useoutertheme{infolines}
\setbeamertemplate{headline}{}
\setbeamertemplate{footline}{
  \hfill
  \usebeamercolor[fg]{page number in head/foot}
  \usebeamerfont{page number in head/foot}
  \insertpagenumber\kern1em\vskip10pt
}
\setbeamertemplate{navigation symbols}{}

\usepackage{tikz}
\usetikzlibrary{arrows}

\title{Lightweight Functional Logic Meta-Programming}
\subtitle{in Scala}
\author{Nada Amin, Tiark Rompf}
\institute{LAMP, EPFL}
\date{March 4, 2014}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]{Logic Programming (Prolog)}
\begin{columns}
\begin{column}[t]{8cm}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (1) {a};
  \node[main node] (2) [below right of=1] {b};
  \node[main node] (3) [below left of=1] {c};

  \path[every node/.style={font=\sffamily\small}]
    (1) edge node [right] {} (2)
    (2) edge node [right] {} (3)
    (3) edge node [right] {} (1);

\end{tikzpicture}
\begin{minted}{prolog}
edge(a,b).
edge(b,c).
edge(c,a).

path(X, Y) :- edge(X, Y).
path(X, Z) :- edge(X, Y), path(Y, Z).
\end{minted}
\end{column}
\begin{column}[t]{4cm}
\begin{minted}{prolog}
?- edge(a, X).
X = b.

?- edge(X, a).
X = c.

?- path(a, X).
X = b ;
X = c ;
X = a ;
X = b .
\end{minted}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Logic Programming (Scala)}
\begin{minted}{scala}
def edge(x: Exp[String], y: Exp[String]): Rel =
  (x === "a") && (y === "b") ||
  (x === "b") && (y === "c") ||
  (x === "c") && (y === "a")

def path(x: Exp[T], y: Exp[T]): Rel =
  edge(x,y) ||
  exists[T] { z => edge(x,z) && path(y,b) }

// Queries
run[(String,String)] { case Pair(x,y) => edge(x,y) }
//=> pair(a,b), pair(b,c), pair(c,a)

runN[String](10) { q => path("a",q) }
//=> b, c, a, b, c, a, b, c, a, b
\end{minted}
\end{frame}

\begin{frame}[fragile]{Deep Linguistic Reuse: OO Encapsulation}
\begin{minted}{scala}
trait Graph[T] {
  def edge(x: Exp[T], y: Exp[T]): Rel
  def path(x: Exp[T], y: Exp[T]): Rel =
    edge(x,y) ||
    exists[T] { z => edge(x,z) && path(y,b) }
}
val g = new Graph[String] {
  def edge(x:Exp[String],y:Exp[String]) =
    (x === "a") && (y === "b") ||
    (x === "b") && (y === "c") ||
    (x === "c") && (y === "a")
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Deep Linguistic Reuse: Type Classes}
\begin{minted}{scala}
trait Ord[T] { def lt(x:Exp[T],y:Exp[T]): Rel }

implicit class OrdOps[T:Ord](x:Exp[T]) {
  def <(y:Exp[T]): Rel =
    implicitly[Ord[T]].lt(x,y)
}

implicit val ordNat = new Ord[Int] {
  def lt(x:Exp[Int],y:Exp[Int]): Rel =
    // ... elided
}


run[Int] { q => q < 4 } //=> 0,1,2,3
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type Classes: Lexicographic Ordering on Polymorphic Lists}
\begin{minted}{scala}
implicit def ordList[T:Ord] = new Ord[List[T]] {
  def lt(as:Exp[List[T]],bs:Exp[List[T]]): Rel = 
    exists[T,List[T]] { (b,bs1) => 
      (bs === cons(b,bs1)) && {
      (as === nil) || exists[T,List[T]] { (a,as1) =>
      (as === cons(a,as1)) && {
      (a < b) || (a === b) && (as1 < bs1) }}}}

run[List[Int]] { q => q < List(0,1,2) }
//=> nil
//   cons(z,nil)
//   cons(z,cons(z,x0))
//   cons(z,cons(s(z),nil)),
//   cons(z,cons(s(z),cons(z,x0)))
//   cons(z,cons(s(z),cons(s(z),x0)))
\end{minted}
\end{frame}

\begin{frame}[fragile]{Type Classes: Run Queries Forwards and Backwards}
\begin{minted}{scala}
run[String] { q =>
  val t = tree(List(1,1,1) -> "a",
               List(1,2,2) -> "b",
               List(2,1,1) -> "c")
  lookup(t,List(1,2,2),q)
} //=> b
run[Int] { q =>
  val t = tree(List(1,1,1) -> "a",
               cons(q,List(2,2)) -> "b",
               List(2,2,2) -> "c")
  lookup(t,List(1,2,2),"b")
} //=> 1
\end{minted}
\end{frame}

\begin{frame}[fragile]{Vanilla Meta-Interpreter (Prolog)}
\begin{minted}{prolog}
/*
  A meta-interpreter for pure Prolog (Art of Prolog, 17.5)

  solve(Goal) :-
     Goal is true given the pure Prolog program defined by
     clause/2.
*/

     solve(true).
     solve((A,B)) :- solve(A), solve(B).
     solve(A) :- clause(A,B), solve(B).
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tracing Meta-Interpreter (Prolog)}
\begin{minted}{prolog}
/*  
  A tracer for Prolog (Art of Prolog 17.7)
*/
		 
solve_trace(Goal) :-
	solve_trace(Goal,0).
     solve_trace(true,Depth) :- !.
     solve_trace((A,B),Depth) :-  !,
        solve_trace(A,Depth), solve_trace(B,Depth). 
     solve_trace(A,Depth) :-  
	builtin(A), !, A, display(A,Depth), nl.
     solve_trace(A,Depth) :-
        clause(A,B), 
	display(A,Depth), nl,
	Depth1 is Depth + 1, 
	solve_trace(B,Depth1).
\end{minted}
\end{frame}

\begin{frame}[fragile]{Tracing (Scala)}
\begin{minted}{scala}
val globalTrace = DVar(nil: Exp[List[List[String]]])
def path(x: Exp[T], y: Exp[T]): Rel = {
  globalTrace := cons(term("path",List(x,y)), globalTrace())
  edge(x,y) || exists[T] { z => edge(x,z) && path(y,b) }
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{Modular Tracing (Scala)}
\begin{minted}{scala}
trait TracingGraph[T] extends Graph[T] {
  override def path(x:Exp[T],y:Exp[T]) =
    rule("path")(super.path)(x,y)
}
// tracing logic
val globalTrace = DVar(nil: Exp[List[List[String]]])
def rule[T,U](s: String)(f: (Exp[T],Exp[U]) => Rel):
  (Exp[T],Exp[U]) => Rel =
  { (a,b) =>
    globalTrace := cons(term(s,List(a,b)), globalTrace())
    f(a,b)
  }

runN[(String,List[String])](5) { case Pair(q1,q2) =>
      g.path("a",q1) && globalTrace() === q2 }
//=> pair(b,cons(path(a,b),nil)),
//   pair(c,cons(path(b,c),cons(path(a,c),nil))), ...
\end{minted}
\end{frame}

\begin{frame}[fragile]{Probabilistic Logic Computation}
\begin{minted}{scala}
val theprob = DVar(1.0)
def flip(p: Double)(a: => Rel)(b: => Rel): Rel =
  { theprob := theprob() * p; a } ||
  { theprob := theprob() * (1.0 - p); b }

runN[(Boolean,Double)](3) { case Pair(c,p) =>
  flip(0.2,c) && { p === theprob() } }
//=> pair(true,0.2), pair(false,0.8)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Clause Reification as Controlled Side Effect (Ex.)}
\begin{minted}{scala}
var allclauses = Map[String,Clause]()
def reifyClause(goal: => Rel)(
    head: Exp[Goal], body: Exp[List[Goal]]): Rel =
  reifyGoals(goal)(cons(head,nil)) &&
  allclauses(extractKey(head))(head,body)
run[List[Any]] { q =>
  exists[Goal,List[Goal]] { (head,body) =>
    q === cons("to prove", cons(head, 
          cons("prove", cons(body, nil)))) &&
    reifyClause(path(g)(fresh,fresh))(head,body)
  }
}
// cons(to prove,cons(path(a,b),cons(prove,cons(nil,nil)))),
// ... 2 more
// cons(to prove,cons(path(a,x0),
//   cons(prove,cons(cons(path(b,x0),nil),nil)))), 
// ... 2 more
\end{minted}
\end{frame}

\begin{frame}[fragile]{Clause Reification as Controlled Side Effect (Impl.)}
\begin{minted}{scala}
val moregoals = DVar(fresh[List[Goal]])
def reifyGoals(goal: => Rel)(goals: Exp[List[Goal]]): Rel = {
  moregoals := goals
  goal && moregoals() === nil
}
def reflectGoal(goal: Exp[Goal]): Rel = {
  val hole = moregoals()
  moregoals := fresh
  hole === cons(goal,moregoals())
}
// reifyGoals(reflectGoal("path(a,b)")
//=>  "cons(path(a,b),nil)"

def rule[A,B](s: String)(f:(Exp[A], Exp[B]) => Rel) = {
  // ...
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{The End}
\begin{itemize}
\item also implemented tabling (memoization semantics)
\item take-away messages
\begin{itemize}
\item like in LMS, exploit deep linguistic reuse
\item use virtualization instead of reflection for meta-programming
\end{itemize}
\end{itemize}
\end{frame}

\end{document}
